# 复合事件

## 1. 是什么

通俗地说，React的合成事件就是对浏览器原生事件的一个二次封装。这种封装的目的是为了在不同的浏览器中提供一致的事件行为，从而简化开发者的工作。

## 2. 为什么

1. **兼容性好**：React 合成事件帮你处理了不同浏览器之间的差异，你不用担心在不同浏览器上事件表现不一致的问题。
2. **性能更好**：React 会把所有事件监听器放在一个地方管理(事件委托)，这样可以减少内存使用和提高性能。
3. **使用简单**：合成事件提供了一个统一的接口，你可以更简单地使用事件处理功能，而不用考虑底层的复杂性。
4. **自动管理**：当组件不再需要时，React 会自动帮你清理掉事件监听器，避免内存泄漏。

## 3. 案例

下面是一个React组件，这个组件直接渲染在React根组件下，也就是#root下

在组件初始化时使用`addEventLinster`分别给document、body、root绑定了冒泡和捕获事件

然后又给`.outer`和`.inner`使用react的方式绑定了冒泡和捕获事件

**代码片段**

样式

```less
.center {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

#root {
  .center;
  width: 300px;
  height: 300px;
  background-color: blue;
}
#outer {
  .center;
  width: 200px;
  height: 200px;
  background-color: green;
}

#inner {
  .center;
  width: 100px;
  height: 100px;
  background-color: red;
}

```

jsx组件

```jsx
const Demo1 = memo(() => {
  // 生成一个函数
  const generFn = (msg) => {
    return (e) => {
      console.log(msg);
    };
  };

  useEffect(() => {
    const documentCaptureFn = generFn("document 捕获");
    const documentFn = generFn("document 冒泡");
    const bodyCaptureFn = generFn("body 捕获");
    const bodyFn = generFn("body 冒泡");
    const rootCaptureFn = generFn("root 捕获");
    const rootFn = generFn("root 冒泡");
    const outerCaptureFn = generFn("outer 捕获「原生」");
    const outerFn = generFn("outer 冒泡「原生」");
    const innerCaptureFn = generFn("inner 捕获「原生」");
    const innerFn = generFn("inner 冒泡「原生」");
    const rootEl = document.getElementById("root");
    const outerEl = document.getElementById("outer");
    const innerEl = document.getElementById("inner");

    document.addEventListener("click", documentCaptureFn, true);
    document.addEventListener("click", documentFn, false);

    document.body.addEventListener("click", bodyCaptureFn, true);
    document.body.addEventListener("click", bodyFn, false);

    rootEl?.addEventListener("click", rootCaptureFn, true);
    rootEl?.addEventListener("click", rootFn, false);

    outerEl?.addEventListener("click", outerCaptureFn, true);
    outerEl?.addEventListener("click", outerFn, false);

    innerEl?.addEventListener("click", innerCaptureFn, true);
    innerEl?.addEventListener("click", innerFn, false);
  }, []);

  return (
    <div
      id="outer"
      onClick={(e) => {
        console.log("outer 冒泡「合成」");
      }}
      onClickCapture={() => {
        console.log("outer 捕获「合成」");
      }}
    >
      <div
        id="inner"
        onClick={() => {
          console.log("inner 冒泡「合成」");
        }}
        onClickCapture={() => {
          console.log("inner 捕获「合成」");
        }}
      ></div>
    </div>
  );
});
```

## 4. React17及之后的事件委托

**问题**

点击inner的时候`理论上`应该如下输出，因为事件的捕获是从最外层然后到点击的目标元素，`addEventListener`属于二级事件监听，可以添加多个，且先添加的先执行，所以下面的输出很合理

```
document 捕获
body 捕获
root 捕获
outer 捕获「原生」
outer 捕获「合成」
inner 捕获「原生」
inner 捕获「合成」
inner 冒泡「原生」
inner 冒泡「合成」
outer 冒泡「原生」
outer 冒泡「合成」
root 冒泡
body 冒泡
document 冒泡
```

但实际输出确是

```
document 捕获
body 捕获
outer 捕获「合成」
inner 捕获「合成」
root 捕获
outer 捕获「原生」
inner 捕获「原生」
inner 冒泡「原生」
outer 冒泡「原生」
inner 冒泡「合成」
outer 冒泡「合成」
root 冒泡
body 冒泡
document 冒泡
```

发现实际输出和理论输出不一样 这是怎么回事？

**解释**

这是因React中给每个事件做了事件委托，`React17及之后`委托到了根元素上也就是`#root`元素

React会在页面渲染的时候给`#root`绑定一个捕获和冒泡事件，这个**优先级是高于**我们在组件渲染的时候手动给`#root`绑定的事件的，因为因为我们手动注册的是在React渲染之后才能去注册

我们使用React事件的写法`<div onClick={()=>{...}} onClickCapture={()=>{...}}></div`实际上是把`onClick`和`onClickCapture`作为`自定义属性`绑定到元素上的

**捕获阶段**

当root触发了事件监听，会获取到捕获的路径，然后遍历这个路径，看是否有`onClickCapture`属性，如果有就获取到改属性的值 然后触发

```js
root.addEventListener('click', (e) => {
  //  e.composedPath()获取的是事件的传播路
  // 因为获取的路径第一项是触发的目标元素 所以要反转一下
  const path = e.composedPath().reverse()
  path.forEach((ele) => {
    let handle = ele.onClickCapture
    if (handle) handle()
  })
}, true)
```

**冒泡阶段**

当root触发了事件监听，会获取到捕获的路径，然后遍历这个路径，看是否有`onClick`属性，如果有就获取到改属性的值 然后触发

```js
root.addEventListener('click', (e) => {
    const path = e.composedPath()
    path.forEach((ele) => {
      let handle = ele.onClick
      if (handle) handle()
    })
  }, false)
```

### **实现合成事件**

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    .center {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }

    #root {
      width: 300px;
      height: 300px;
      background-color: blue;
    }

    #outer {
      width: 200px;
      height: 200px;
      background-color: green;
    }

    #inner {
      width: 100px;
      height: 100px;
      background-color: red;
    }
  </style>
</head>

<body>
  <div id="root" class="center">
    <div id="outer" class="center">
      <div id="inner" class="center">
      </div>
    </div>
  </div>


  <script>
    /*
    注意：
    react17之前 事件委托是绑定到document上的 17之后是绑定到root的
    react系统注册事件的时机最高 所以后期手动给root添加的事件要晚于react给root添加的事件
    */

    /*
     <div
      className="outer"
      onClick={(e) => {
        console.log('outer 冒泡「合成」')
      }}
      onClickCapture={() => {
        console.log('outer 捕获「合成」')
      }}
    >
      <div
        className="inner"
        onClick={() => {
          console.log('inner 冒泡「合成」')
        }}
        onClickCapture={() => {
          console.log('inner 捕获「合成」')
        }}
      ></div>
    */
    // 上面是jsx的语法 React会把onClick和onClickCapture作为属性添加到html元素中 不过因为值是函数 react回把他们转换类似下面的写法
    outer.onClick = () => { console.log('outer 冒泡「合成」') }
    outer.onClickCapture = () => { console.log('outer 捕获「合成」') }
    inner.onClick = () => { console.log('inner 冒泡「合成」') }
    inner.onClickCapture = () => { console.log('inner 捕获「合成」') }

    // 用于生成一个函数 用于打印事件的信息
    const generFn = (msg, needE = false) => {
      return (e) => {
        console.log(msg)
        needE && console.log(e.composedPath())
      }
    }

    const documentCaptureFn = generFn('document 捕获')
    const documentFn = generFn('document 冒泡')
    const bodyCaptureFn = generFn('body 捕获')
    const bodyFn = generFn('body 冒泡')
    const rootCaptureFn = generFn('root 捕获',)
    const rootFn = generFn('root 冒泡')
    const outerCaptureFn = generFn("outer 捕获「原生」");
    const outerFn = generFn("outer 冒泡「原生」");
    const innerCaptureFn = generFn("inner 捕获「原生」");
    const innerFn = generFn("inner 冒泡「原生」");



    document.addEventListener('click', documentCaptureFn, true)
    document.addEventListener('click', documentFn, false)

    document.body.addEventListener('click', bodyCaptureFn, true)
    document.body.addEventListener('click', bodyFn, false)


    outer.addEventListener("click", outerCaptureFn, true);
    outer.addEventListener("click", outerFn, false);

    inner.addEventListener("click", innerCaptureFn, true);
    inner.addEventListener("click", innerFn, false);


    // 这块模拟的是react给root添加的事件 优先级高于手动给root添加的事件
    root.addEventListener('click', (e) => {
      // e.composedPath()获取的是事件的传播路
      // 因为获取的路径第一项是触发的目标元素 所以要反转一下
      const path = e.composedPath().reverse()
      path.forEach((ele) => {
        let handle = ele.onClickCapture
        if (handle) handle()
      })
    }, true)

    root.addEventListener('click', (e) => {
      const path = e.composedPath()
      path.forEach((ele) => {
        let handle = ele.onClick
        if (handle) handle()
      })
    }, false)

    // 这里是是手动添加的事件
    root.addEventListener('click', rootCaptureFn, true)
    root.addEventListener('click', rootFn, false)


  </script>
</body>

</html>
```

### 分步解析

有了上面的知识铺垫接下来分布解析，当点击inner的时候过程如下

1. 触发window的捕获，没有绑定事件，无结果
2. 触发document的捕获，打印 `document 捕获`
3. 触发html的捕获，没有绑定事件，无结果
4. 触发body的捕获，打印 `body 捕获`
5. 触发root的捕获
   1. 首先触发了React给root绑定的捕获事件
      1. 执行outer的`onClickCapture` 打印 `outer 捕获「合成」`
      2. 执行inner的`onClickCapture` 打印 `inner 捕获「合成」`

   2. 然后触发手动给root绑定的捕获事件 打印`root 捕获`

6. 触发outer的捕获，打印 `outer 捕获「原生」`
7. 触发inner的捕获，打印 `outer 捕获「原生」`
8. 触发inner的冒泡，打印 `inner 冒泡「原生」`
9. 触发outer的冒泡，打印 `outer 冒泡「原生」`
10. 触发root的冒泡，
   1. 首先触发了React给root绑定的冒泡事件
      1. 执行inner的`onClick` 打印 `inner 冒泡「合成」`
      2. 执行outer的`onClick` 打印 `outer 冒泡「合成」`
   2. 然后触发手动给root绑定的冒泡事件 打印`root 冒泡`

11. 触发body的冒泡，打印 `body 冒泡`
12. 触发html的冒泡，没有绑定事件，无结果
13. 触发document的冒泡，打印 `document 冒泡`
14. 触发window的冒泡，没有绑定事件，无结果

## 5. React16的事件委托

React16是把委托放到了`document`元素上，且只对`冒泡事件`做了处理

React会给document在渲染前绑定一个冒泡事件

```js
document.addEventListener('clik',()=>{
  const path = e.composedPath()
  
  // 处理捕获阶段的事件
  path.reverse().forEach((ele) => {
    let handle = ele.onClickCapture
    if (handle) handle()
  })
  
  // 处理冒泡阶段的事件
  path.reverse().forEach((ele) => {
    let handle = ele.onClick
    if (handle) handle()
  })
},false)
```



所以如果代码放到React16中会有如下的输出

```
document 捕获
body 捕获
root 捕获
outer 捕获「原生」
inner 捕获「原生」
inner 冒泡「原生」
outer 冒泡「原生」
root 冒泡
body 冒泡
outer 捕获「合成」
inner 捕获「合成」
inner 冒泡「合成」
outer 冒泡「合成」
document 冒泡
```



### 分步解析

1. 触发window的捕获，没有绑定事件，无结果
2. 触发document的捕获，打印 `document 捕获`
3. 触发html的捕获，没有绑定事件，无结果
4. 触发body的捕获，打印 `body 捕获`
5. 触发root的捕获，打印 `root 捕获`
6. 触发outer的捕获，打印 `outer 捕获「原生」`
7. 触发inner的捕获，打印 `inner 捕获「原生」`
8. 触发inner的冒泡，打印 `inner 冒泡「原生」`
9. 触发outer的冒泡，打印 `outer 冒泡「原生」`
10. 触发root的冒泡， 打印`root 冒泡`
11. 触发body的冒泡，打印 `body 冒泡`
12. 触发html的冒泡，没有绑定事件，无结果
13. 触发React给document的冒泡事件
    1. 首先处理`onClickCapture`
       1. 执行outer的`onClickCapture` 打印`outer 捕获「合成」`
       2. 执行inner的`onClickCapture` 打印`inner 捕获「合成」`
    2. 然后处理`onClick`
       1. 执行inner的`onClick` 打印`inner 冒泡「合成」`
       2. 执行outer的`onClick` 打印`outer 冒泡「合成」`
14. 触发手动给document的冒泡事件，打印`document 冒泡`
15. 触发window的冒泡，没有绑定事件，无结果

# 合成事件对象

## 1. `stopImmediatePropagation`和`stopPropagation`的区别

**stopImmediatePropagation** MDN定义

>如果多个事件监听器被附加到相同元素的相同事件类型上，当此事件触发时，它们会按其被添加的顺序被调用。如果在其中一个事件监听器中执行 `stopImmediatePropagation()` ，那么剩下的事件监听器都不会被调用。

**举例**

```html
<div id="inner">
Inner
</div>

<script>
  // 事件1
  inner.addEventListener('click', (e) => console.log('inner 冒泡1'))

  // 事件2
  inner.addEventListener('click', (e) => {
    // e.stopPropagation()
    e.stopImmediatePropagation()
    console.log('inner 冒泡2')
  })

  // 事件3
  inner.addEventListener('click', (e) => console.log('inner 冒泡3'))
</script>
```

分别给`#inner`绑定了三个冒泡事件，如果在事件2中使用`stopPropagation()`那么当点击inner会如下输出

```
inner 冒泡1
inner 冒泡2
inner 冒泡3
```

因为`stopPropagation`只会阻止向上冒泡，阻止不了同级的其他事件



如果在事件2中使用`stopImmediatePropagation()`那么当点击inner会如下输出

```
inner 冒泡1
inner 冒泡2
```

`stopImmediatePropagation()`可以阻止当前事件之后的同级事件，因为事件1是先绑定的所以无法阻止，事件3后绑定的，可以阻止



## 2. 合成事件对象解析

上面说到react的合成事件，拿来举例，React会对原始的事件对象进行包装，然后传递给合成事件的第一个参数，作为合成事件的事件对象，这个合成之后的事件的对象有一个`nativeEvent`属性指向的是原始的事件对象，合成事件对象上面囊括了常用的属性和方法，以及`stopPropagation`和`preventDefault`，但是没有`stopImmediatePropagation`这个方法

```js
root.addEventListener('click', (e) => {
    const path = e.composedPath()
    path.forEach((ele) => {
      let handle = ele.onClick
      // 下面是个伪代码 表示react会对原生对象进行包装
      const syntheticEv = 包装原始对象函数(e)
      if (handle) handle(syntheticEv)
    })
  }, false)
```



**举例**

下面是对案例中的代码进行调整

```jsx
<div 
  id="inner"
  onClick={(e)=> {
    // e表示的是合成事件对象
     console.log("inner 冒泡「合成」");
    // e.stopPropagation() 作用 阻止原生事件传播 & 阻止合成事件中的事件传播
    // e.nativeEvent.stopImmediatePropagation() 只能阻止原生事件的传播
  }}
</div>
```

**拿“React17及之后”的案例来说**

如果使用`e.stopPropagation() ` 会阻止原生的事件传播以及合成事件传播 但是`root冒泡`会打印，因为stopPropagation不能阻止同级别的其他事件蔓延

| 原始输出                                                     | 更改之后的输出                                               |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| document 捕获<br/>body 捕获<br/>outer 捕获「合成」<br/>inner 捕获「合成」<br/>root 捕获<br/>outer 捕获「原生」<br/>inner 捕获「原生」<br/>inner 冒泡「原生」<br/>outer 冒泡「原生」<br/>inner 冒泡「合成」<br/>outer 冒泡「合成」<br/>root 冒泡<br/>body 冒泡<br/>document 冒泡 | document 捕获<br />body 捕获<br/>outer 捕获「合成」<br/>inner 捕获「合成」<br/>root 捕获<br/>outer 捕获「原生」<br/>inner 捕获「原生」<br/>inner 冒泡「原生」<br/>outer 冒泡「原生」<br/>inner 冒泡「合成」<br/>root 冒泡<br /><br /><br /> |

如果使用`e.nativeEvent.stopImmediatePropagation() ` 只能阻止原生的事件蔓延，所以可以看到`outer 冒泡「合成」`被打印了 

| 原始输出                                                     | 更改之后的输出                                               |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| document 捕获<br/>body 捕获<br/>outer 捕获「合成」<br/>inner 捕获「合成」<br/>root 捕获<br/>outer 捕获「原生」<br/>inner 捕获「原生」<br/>inner 冒泡「原生」<br/>outer 冒泡「原生」<br/>inner 冒泡「合成」<br/>outer 冒泡「合成」<br/>root 冒泡<br/>body 冒泡<br/>document 冒泡 | document 捕获<br />body 捕获<br/>outer 捕获「合成」<br/>inner 捕获「合成」<br/>root 捕获<br/>outer 捕获「原生」<br/>inner 捕获「原生」<br/>inner 冒泡「原生」<br/>outer 冒泡「原生」<br/>inner 冒泡「合成」<br/>outer 冒泡「合成」<br /><br /><br /> |

**React16中的同理，只不过阻止冒泡是阻止`document`元素之后的**
