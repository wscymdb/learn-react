<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    .center {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }

    #root {
      width: 300px;
      height: 300px;
      background-color: blue;
    }

    #outer {
      width: 200px;
      height: 200px;
      background-color: green;
    }

    #inner {
      width: 100px;
      height: 100px;
      background-color: red;
    }
  </style>
</head>

<body>
  <div id="root" class="center">
    <div id="outer" class="center">
      <div id="inner" class="center">
      </div>
    </div>
  </div>


  <script>
    /*
    注意：
    react17之前 事件委托是绑定到document上的 17之后是绑定到root的
    react系统注册事件的时机最高 所以后期手动给root添加的事件要晚于react给root添加的事件
    */

    /*
     <div
      className="outer"
      onClick={(e) => {
        console.log('outer 冒泡')
      }}
      onClickCapture={() => {
        console.log('outer 捕获')
      }}
    >
      <div
        className="inner"
        onClick={() => {
          console.log('inner 冒泡')
        }}
        onClickCapture={() => {
          console.log('inner 捕获')
        }}
      ></div>
    */
    // 上面是jsx的语法 会把onClick和onClickCapture作为属性添加到html元素中 不过因为值是函数 react回把他们转换类似下面的写法
    outer.onClick = () => { console.log('outer 冒泡「合成」') }
    outer.onClickCapture = () => { console.log('outer 捕获「合成」') }
    inner.onClick = () => { console.log('inner 冒泡「合成」') }
    inner.onClickCapture = () => { console.log('inner 捕获「合成」') }

    const generFn = (msg, needE = false) => {
      return (e) => {
        console.log(msg)
        needE && console.log(e.composedPath())
      }
    }
    const documentCaptureFn = generFn('document 捕获')
    const documentFn = generFn('document 冒泡')
    const bodyCaptureFn = generFn('body 捕获')
    const bodyFn = generFn('body 冒泡')
    const rootCaptureFn = generFn('root 捕获',)
    const rootFn = generFn('root 冒泡')


    document.addEventListener('click', documentCaptureFn, true)
    document.addEventListener('click', documentFn, false)

    document.body.addEventListener('click', bodyCaptureFn, true)
    document.body.addEventListener('click', bodyFn, false)

    root.addEventListener('click', (e) => {
      // composedPath获取的是捕获路径
      const path = e.composedPath().reverse()
      console.log(path)
      path.forEach((ele) => {
        let handle = ele.onClickCapture
        if (handle) handle()
      })
    }, true)

    root.addEventListener('click', (e) => {
      const path = e.composedPath()
      console.log(path)
      path.forEach((ele) => {
        let handle = ele.onClick
        if (handle) handle()
      })
    }, false)

    root.addEventListener('click', rootCaptureFn, true)
    root.addEventListener('click', rootFn, false)


  </script>
</body>

</html>